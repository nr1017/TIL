# **고정 소수점 & 부동 소수점**


컴퓨터는 2진법으로 수를 저장함

> 실수 : 정수부 + 소수부
> 
> - 정수부 → 정수 변환과 같음(나누기2, 1나올때까지)
> - 소수부 → 정수 변환과 정반대(곱하기2, 0나올때 까지)

<br>

```jsx
//0.75를 2진법으로 변환

0.75 * 2 = 1.5 --> 1을 빼고 나머지 0.5
0.5 * 2 = 1.0 --> 1을 빼고 나머지 0

빼낸 숫자들을 위에서 부터 읽어주면 됨

0.75 => 0.11
```
<br><br>

## 컴퓨터에서 실수(real number)를 표현하는 방법 2가지

<br>

### 1. **고정 소수점(Fixed Point)**

10진수를 2진수로 변환한 뒤 그대로 표현하는 방식

- 맨 앞 1자리 → 부호비트, 0이면 양수 1이면 음수
- 나머지 비트들은 소수점을 기준으로 정수부와 소수부로 나뉜다. 이때 소수점의 위치는 미리 정해둠
- 소수부의 경우 앞에서부터 채우며 남는 뒷자리는 다 0으로 채운다

<br>

> **장점** : 실수를 정수부와 소수부로 표현하여 단순하다.
>
> **단점** : 표현의 범위가 너무 적어서 활용하기 힘들다. (정수부는 15bit, 소수부는 16bit)


<br><br>

### 2. **부동 소수점(Floating Point)**

10진수를 2진수로 변환한 결과에서 몇가지 과정을 추가로 거치는 방식

- 정규화(1.xxxxx * 2^n 의 형식으로 변환)

```jsx
// 111.101 을 정규화

정수부에 1만 남을때까지 소수점을 왼쪽으로 이동 -> 이동한 칸수 만큼 n 자리에 넣기
정수부가 0일 경우에는 1만 남을때까지 오른쪽으로 이동 -> 이동한 칸수 만큼 -n 자리에 넣기

111.101 => 1.11101* 2^2
0.000101 => 1.01* 2^-4
```
<br>
- IEEE 754 부동소수점 표현
<br>

- 맨 앞 1자리 → 부호비트, 0이면 양수 1이면 음수 (고정 소수점과 동일)
- 23자리 가수부 → 정규화 결과 소수점 오른쪽 숫자들을 왼쪽부터 채우며 남는 뒷자리는 0으로 채운다
- 8자리 지수부 → 2^n 에서 n에 해당하는 수를 2진수로 바꾼 값을 넣는다.
    - IEEE 표준에 따라 bias 라는 지정된 숫자를 더해야 함
    - 32비트의 경우 bias 는 127
    
    ```jsx
    //위에서 111.101 을 정규화 한 값이 1.11101*2^2
    
    2 + 127 = 129 
    
    129를 2진수로 바꾼 값 => 10000001
    ```
    <br>

> **장점** : 표현할 수 있는 수의 범위가 넓어진다. (현재 대부분 시스템에서 활용 중)
> 
> **단점** : 오차가 발생할 수 있다. (부동소수점으로 표현할 수 있는 방법이 매우 다양함)

